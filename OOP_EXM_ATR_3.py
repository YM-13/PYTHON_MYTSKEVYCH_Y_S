class User:
    name = "Alex" # атрибут (переменная)
    age = 17      # атрибут (переменная)

    def get_name(self, name):      # МЕТОД, КОТОРЫЙ ВЫВОДИТ ИМЯ. Принимаем атрибут self
        print(self, name)

    def get_age(self, age):       # МЕТОД, КОТОРЫЙ ВЫВОДИТ ВОЗРАСТ. Принимаем атрибут self
        print(self, age)     # перед названием переменной мы также указываем self,
    # проще говоря, мы изначально (сначала) обращаемся к текущему экземпляру и после чего внутри него
    # обращаемся к определенному атрибуту. Так как изначально при создании объекта пайтону нужно понять
    # к какому экземпляру оно принадлежит. Как мы помним self ссылается на текущие экземпляры класса,
    # если у нас будет 10 экземпляров, то каждый атрибут self внутри каждого экземпляра будет ссылаться
    # только на свой экземпляр. Тем самым когда внутри мы обращаемся к self и вызываем переменную, он
    # будет знать, что нужно обращаться именно к этой переменной текущего экземпляра

a = User() # ЭКЗЕМПЛЯРЫ, которые ссылаются на одни и те же данные (атрибуты класса)
b = User() # если изменяются данные в классе, они изменятся в экземплярах
c = User() # либо нужно в каждом экземпляре создать новые данные:

a.name = "Alex" # Здесь "а" - экземпляр класса, "name" - переопределяем атр класс для "а"
b.name = "name1"
c.name = "name2"
print(id(a.name))

#print(User.get_name()) # В ТАКОМ ВИДЕ ВЫЗОВЕТ ОШИБКУ. ТАК КАК ЗДЕСЬ МЕТОД ССЫЛАЕТСЯ НА self.name, т.е.
# на объект экземпляра, а не напрямую на name: в данном случае нужно обязательно создавать ЭКЗЕМПЛЯР,
# если же мы просто обращаемся к самому классу он пытается найти name внутри self т.е. внутри нашего
# экземпляра, но т.к. мы обращаемся к самому классу у него нет экземпляра и поэтому он выдает нам ошибку;
# поэтому данные методы мы можем вызвать с помощью экземпляров:
print(a.name)
print(b.name)
print(c.name)


print(a.age)
User.age = 33
print(b.age)
c.age = 41
print(c.age)


